#include "userService.h"
#include "../../models/usermodel/userModel.h"
#include "../peachdb/peachdb.h"
#include <string.h>
#include <stdio.h>

int UserService_createDocument() {
    // First, ensure the database service itself is initialized
    if (Peach_initPeachDb() != 0) {
        fprintf(stderr, "UserService Error: Failed to initialize PeachDB.\n");
        return -1;
    }

    // Attempt to create the 'user' collection.
    // Peach_collection_create is idempotent; it won't fail if the collection already exists.
    Peach_collection_create("user", "id^username^password");

    // Create collections for messaging features
    Peach_collection_create("messages", "id^senderId^receiverId^message^time");
    Peach_collection_create("groups", "groupId^groupName^ownerId");
    Peach_collection_create("groupusers", "id^groupId^userId");
    Peach_collection_create("groupmessages", "id^groupId^senderId^message^time");

    // It will, however, return -1 on other critical errors, which we pass up.
    return 0;
}

long UserService_register(const char* username, const char* password) {
    if (username == NULL || password == NULL) {
        return -1; // Invalid input
    }

    // Check if user already exists
    User* existing_user = User_read_by_username(username);
    if (existing_user != NULL) {
        User_free(existing_user);
        fprintf(stderr, "UserService Error: Username '%s' already exists.\n", username);
        return -1; // Username is taken
    }

    // TODO: Hash the password before storing it. For now, storing plaintext.
    User new_user_data = {
        .id = 0, // ID is generated by User_create
        .username = (char*)username,
        .password = (char*)password
    };

    return User_create(&new_user_data);
}

User* UserService_login(const char* username, const char* password) {
    if (username == NULL || password == NULL) {
        return NULL;
    }

    User* stored_user = User_read_by_username(username);
    if (stored_user == NULL) {
        return NULL; // User not found
    }

    // TODO: Use a secure hash comparison instead of strcmp.
    if (strcmp(password, stored_user->password) == 0) {
        // Passwords match, return the user struct.
        // The caller is now responsible for freeing this memory.
        return stored_user;
    } else {
        // Passwords do not match, free the struct and return NULL.
        User_free(stored_user);
        return NULL;
    }
}

int UserService_delete(long id) {
    return User_delete(id);
}
